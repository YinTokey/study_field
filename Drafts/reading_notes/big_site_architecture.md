# C1

### 概述

关键词：高可用，高性能，易扩展，可伸缩，安全。

### 网站特性

- 高并发，大流量

- 高可用

- 海量数据

- 用户分布广

- 安全环境恶劣

- 需求更变、迭代快

- 渐进式发展

  

  ### 价值观

  业务驱动技术，技术最终为业务服务。有一些技术难题，是可以通过业务层面来解决的。比如12306订票问题，可以优化买票机制，来减少服务器的并发量。

  

  # C2

  

  **分层**：应用层，服务层，数据层（纵向划分）

  **分割**：针对业务模块，进行服务拆分，独立部署。（横向划分）

  **分布式**：应用服务，静态资源，数据和存储，计算，配置

  **集群**：通过均衡负载来处理

  **缓存**：CDN，反向代理（nginx），本地缓存（Redis）,分布式缓存（关注缓存一致性）

  **异步**：避免阻塞

  **冗余**：数据库的冷热备份

  **自动化**：避免人为操作失误。CI/CD，自动化测试，自动化部署，自动化监控，自动化安全风险监测，自动化报警，失效转移，故障自动恢复，降级，资源分配

  **安全**：身份校验

  # C3

  **高性能**：主要指标就是响应要快。比如使用各种缓存，异步多线程等。通过 响应时间，吞吐量，TPS等监控指标去衡量性能。

  **可用性**：

  **扩展性**：新增业务需求时，能否不改动现有的东西，不影响现有的业务。主要使用事件驱动架构（EDA）和微服务架构

  **安全性**

  

  # C4

  **性能测试指标**：并发数，吞吐量（TPS 每秒事务数，HPS 每秒HTTP请求数， QPS 每秒查询数），响应时间。优化性能的核心目的是改善用户体验的响应时间，尽可能提高系统的吞吐量，最大限度利用服务器资源。

  **性能测试报告** 通过性能测试生成报告，分析优化点

  反向代理也可以实现负载均衡。

  

  **服务端性能优化**：

  第一定律：优先使用各种缓存来优化。缓存主要用于哪些 读多写少的数据。

  哪些数据不适合写入缓存？

  - 频繁修改的数据，一般不写入缓存，不然会造成更多麻烦。一般来说读写比 2：1 以上，才有写入缓存的必要。

  - 没有热点访问，不遵循二八定律的数据

  

  **脏读**：缓存失效了，从数据库中读取，这个时间段内，会出现数据不一致问题。

  **缓存雪崩**：缓存服务器崩了，流量都打到数据库上。

  **缓存预热**：启动时将热点数据预加载到缓存中。

  **缓存穿透**:  持续请求某个缓存中没有的数据（可能是恶意的没用数据），流量穿透打到数据库上，严重时导致数据库崩溃。解决办法是把这种垃圾数据也缓存起来，避免穿过去。

  

  大型网站需要 TB 级的缓存，使用缓存集群。

  

  **异步操作** 使用消息队列，将短时间内高并发产生的事务消息存储在消息队列中，实现**流量削峰**的目的。(任何可以晚点再做的事, 都应该晚点再做)

  

  **代码优化**：

  - 将对象设计为无状态对象（对象无成员变量，或者成员变量也是无状态对象）。这样多线程访问时不会状态不一致。

  - 使用局部对象，这样每次多线程访问，都会创建一个全新的对象，不会出现一个对象被多个线程同时访问的情况
  - 多线程并发访问时，要使用锁，确保线程安全。可以尽可能用轻量级的锁。

  - 资源复用（数据库连接池，对象池，线程池等）

  

  **数据结构**:

  一般数据库使用两级索引的B+树，NoSQL一般使用 LSM 树（比B+树更快）。

  

  # C5

  可用性(Availability) --- 工程师 KPI 关联， 4个9 是基本要求，5个9是极其优秀。

  **事故分级与处罚制度**

  7层可用性，谷歌SRE 两本书

  应用服务器尽量不保存状态，这样宕机了，可以无差别快速转移到其他服务器上。

  对于那些状态，专门搭建有状态服务器。针对两种服务器特性，分别设计适合的架构。

  运维层面分级管理：核心业务使用更好的机器，且运维响应优先级设置得更高。比如一些涉及钱的业务。

  隔离

  超时设置

  

  **CAP** 理论：

  C: Consistency 数据一致性，所有应用程序访问到的数据都是一样的

  A：Availibility 数据可用性，任何时候，任何应用程序都可以读写访问

  P: Patition Tolerance 系统具有跨网络分区的伸缩性，扩展性

  

  高可用有几个层面的含义

  - 数据持久性，不会丢失，注意备份。
  - 数据可访问性，
  - 数据一致性

  

  **数据一致性细分**

  - 数据强一致，各个副本的数据在物理存储中都是一样的，如果操作更新失败，那么全部没更新，而不是处于不确定状态。（这种最难实现）
  - 数据用户一致，各个副本数据在物理存储中可能不一致，但是用户访问时，通过纠错和校验机制，可以让用户访问到一致正确的数据。
  - 数据最终一致，最弱的一种一致性。存储可能不一致，用户访问也可以不一致（连续访问，返回的结果不同），但是经过一段时间的自我修复，最终会达到一致。

  

  不允许没有监控的系统上线

  

  # C6

  伸缩性分离，有纵向分离（业务，基础设施，数据库 分离）和横向分离（基于业务类型分离）

  服务器集群：相同的服务在多台机子上构成集群。（一头牛拉不动，就多找几头牛来拉，而不是找一头更强壮的牛）

  应用服务器负载均衡常见方法：

  - 使用HTTP重定向负载均衡
  - DNS负载均衡
  - 反向代理负载均衡
  - IP负载均衡（可以和DNS结合起来，作为第二级负载均衡，DNS是第一级）
  - 数据链路层负载均衡 （Linux Virtual Server）

  

  一致性Hash 环结构

  

  NoSQL的优势在于 **高可用性** 和 **可伸缩性**

  

  伸缩性良好的架构总是走在业务前面，在业务需要处理更多的访问和服务之前就已经做好了准备。当业务需要时，只需要多搞几台服务器简单部署一下就可以了。如何设计架构走在业务的后面，对于公司业务和技术团队都将会是灾难。

  

  # C7

  扩展性和伸缩性的差异：

  **扩展性**是对当前系统影响最小的前提下，需求功能可以持续加上去，改需求的时候能很方便地改动。这种一般基础设施都比较稳定，系统耦合性低。对设计原则中的开闭原则良好应用。其实更多的是强调代码设计优秀。

  

  **伸缩性**是指能够通过增加或减少计算资源（服务器数量等）来提高或减少计算处理事务的能力。

  

  架构师最大的价值不在于掌握了多少先进的技术，而是能将一个大型系统切分成N个低耦合的子模块，这些子模块包括横向业务模块，纵向基础设施模块。这种能力来源于专业技术和经验，还有一部分来源于架构师对业务场景的理解，对人性的把握，甚至对世界的认知。

  

  # C8

  XSS：篡改网页，注入恶意HTML脚本，用户浏览网页时，可以控制用户浏览器进行恶意操作。

  CSRF

  Session 劫持

  SQL注入：攻击者发送含有恶意SQL命令的程序（比如 drop table xxx 删表删库操作）, 服务端基于请求参数构建sql命令时，就把 恶意命令也构建进去了，然后就执行了数据库的破坏性操作。 **如何应对**：通过正则匹配，识别请求参数中含有sql指令，把他们过滤掉

  

  

  

  

  