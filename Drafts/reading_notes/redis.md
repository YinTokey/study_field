

## 03 高性能IO

网络IO 和 KV 读写都由一个线程完成。持久化，集群数据同步等是由其他线程完成。

单线程访问资源，就避免了多线程为了安全所做的额外操作，所以更 **快**。另一部分快的原因是它采用的高效数据结构（哈希表，跳表等）

IO 非阻塞，多路复用保证了吞吐量。

## 04 AOF

Append only file。

三种写回策略，注意大文件带来的性能问题。

AOF 重写机制。

AOF 记录操作。



## 05 RDB

Redis Database 内存快照文件。

RDB 记录数据。 全量快照。

如何保证快照过程数据不变化？先fork主线程，生成一个bgsave子进程。 生成一份不会变的副本，再把副本写入快照文件。

增量快照来保证频率快照的性能开销问题。

`最佳实践`： 两次快照之间，以AOF记录操作。 

## 06 主从一致

主从库读写分离。（可以和 mongodb 的复制集， 分片集群  对比一下）

关注主从同步流程3个步骤。

主 - 从 - 从 模式。 RDB文件是二进制的，相对于AOF会小很多。主从之间基于RDB文件传输。

长连接  和 主从网络断了处理方式。

## 07 主库挂了怎么办

读操作还行，对于写操作，主库挂了往哪写数据？ 把一个从库变成主库（和 mongodb 的选举一样）

`哨兵机制` ：一个redis进程，三个作用： 监控，选举出新的主库，通知。

怎么监控：给所有主从库发  ping 来判断谁挂了。

通知：新的主库选出来后，通知所有从库建立新的主从关系连接。通知客户端谁是新的主库，建立新的客户端 -- 主库连接。

哨兵也有集群。

## 08 哨兵集群



## 09 Redis Cluster

基于 hash slot 来处理数据和redis实例之间的映射关系。一共 16384 个槽。 首先 针对key 计算出它应该落在哪一个哈希槽上。默认做法是：如果集群有N个redis实例，那么每个实例就有 16384/N 个槽（均分槽）。也可以手动指定每个实例有多少个槽。**手动分配时，需要把所有16384槽都分配完，否则无法工作。**

客户端本地有保存映射关系，请求数据时，先计算出哈希槽对应的实例，然后去请求那个实例。

集群中实例的增减，会导致槽的重新分布。请求不到时，会让客户端重定向去请求其他实例。（MOVED, ASK）

`为什么不把key 直接映射到实例，还要增加一层 哈希槽？` 加一层好处挺多的，可以看专栏最底部的回答或者第10讲答疑。 简单地说，键值对数量一般很大，哈希槽才  16384 个，相对数量少多了。

---------

## 11 String 类型缺陷

string 类型万能，但是记录小数据时，数据结构的局限性，导致开销不必要的大（性价比低）。

## 12 海量key的选择



## 14 时间序列数据存储

两种方案： 1. 使用 Hash 和  Sorted Set 结构     2. 使用扩展模块 RedisTimeSeries

## 15 Redis 作为消息队列

可以用 List 或 Streams 来实现轻量级消息队列。

## 24 缓存淘汰策略



## 26 缓存异常

雪崩：大量数据过期，或者redis 宕机。--------  1. 预防式方案（无损）。 2. 降级，熔断，限流等（有损）

击穿：某个热点数据，无法命中缓存。  ------- 超热点数据不设置过期时间。

穿透：数据不在缓存，也不在DB。 -------- 在缓存中设置空值或者缺省值，让请求能被缓存层拦截



## 27 缓存污染
主要基于缓存淘汰策略来解决污染问题，即 LRU 和 LFU。

## 28 大容量 redis
使用 Pika ，存到 SSD 中。

## 29 

## 31 ACID
A: 原子性
C: 一致性
I: 隔离性
D: 持久性
主要是通过 Lua 脚本来实现。

